import path from "node:path";
import { Duration, RemovalPolicy } from "aws-cdk-lib";
import * as events from "aws-cdk-lib/aws-events";
import * as targets from "aws-cdk-lib/aws-events-targets";
import * as iam from "aws-cdk-lib/aws-iam";
import * as lambda from "aws-cdk-lib/aws-lambda";
import * as s3 from "aws-cdk-lib/aws-s3";
import * as secretsmanager from "aws-cdk-lib/aws-secretsmanager";
import { Construct } from "constructs";

export interface KeySpec {
  algorithm: string;
  crv?: string;
  modulusLength?: number;
}

export interface JwksRotationProps {
  /**
   * Name for the AWS Secrets Manager secret to store the private key.
   */
  secretName: string;

  /**
   * Specification for the key pair (algorithm, curve, modulus length, etc.).
   */
  keySpec: KeySpec;

  /**
   * Existing S3 bucket to store the JWKS file.
   * If not provided, a new bucket will be created.
   * @default - undefined
   */
  bucket?: s3.IBucket;

  /**
   * Path/name for the JWKS file in the bucket.
   * @default ".well-known/jwks.json"
   */
  bucketPath?: string;

  /**
   * Name for a new S3 bucket (if `bucket` is not provided).
   * @default - undefined, auto-generated by CDK (recommended)
   */
  bucketName?: string;

  /**
   * How often to rotate keys.
   * @default Duration.days(60)
   */
  rotationInterval?: Duration;

  /**
   * Minimum grace period before a new key is activated.
   * @default Duration.days(7)
   */
  minActivationGracePeriod?: Duration;

  /**
   * How often to check for old keys to clean up.
   * @default Duration.hours(24)
   */
  cleanupCheckInterval?: Duration;

  /**
   * Minimum grace period before deleting old keys.
   * @default Duration.hours(6)
   */
  minKeyCleanupGracePeriod?: Duration;

  /**
   * Maximum duration for which a token signed by a key is considered valid.
   * This influences when outdated keys are removed from the key set.
   */
  maxTokenValidityDuration: Duration;
}

export class JwksRotation extends Construct {
  public readonly bucket: s3.IBucket;
  public readonly secret: secretsmanager.Secret;
  public readonly rotationLambda: lambda.Function;

  constructor(scope: Construct, id: string, props: JwksRotationProps) {
    super(scope, id);

    const {
      secretName,
      bucket: existingBucket,
      bucketPath = ".well-known/jwks.json",
      bucketName,
      rotationInterval = Duration.days(60),
      minActivationGracePeriod = Duration.days(7),
      cleanupCheckInterval = Duration.hours(24),
      minKeyCleanupGracePeriod = Duration.hours(6),
      maxTokenValidityDuration,
      keySpec,
    } = props;

    if (existingBucket) {
      this.bucket = existingBucket;
    } else {
      this.bucket = new s3.Bucket(this, "JwksBucket", {
        bucketName,
        versioned: false,
        publicReadAccess: true,
        blockPublicAccess: s3.BlockPublicAccess.BLOCK_ACLS,
        removalPolicy: RemovalPolicy.DESTROY,
        cors: [
          {
            allowedMethods: [s3.HttpMethods.GET],
            allowedOrigins: ["*"],
            allowedHeaders: ["*"],
          },
        ],
      });
    }

    this.rotationLambda = new lambda.Function(this, "RotationLambda", {
      runtime: lambda.Runtime.NODEJS_22_X,
      handler: "rotation-handler.handler",
      code: lambda.Code.fromAsset(path.join(__dirname, "lambda"), {
        exclude: ["*.d.ts", "*.map"],
      }),
      timeout: Duration.minutes(5),
      environment: {
        BUCKET_NAME: this.bucket.bucketName,
        BUCKET_PATH: bucketPath,
        MIN_ACTIVATION_GRACE_PERIOD_SECONDS: minActivationGracePeriod
          .toSeconds()
          .toString(),
        MAX_TOKEN_VALIDITY_DURATION_SECONDS: maxTokenValidityDuration
          .toSeconds()
          .toString(),
        MIN_KEY_CLEANUP_GRACE_PERIOD_SECONDS: minKeyCleanupGracePeriod
          .toSeconds()
          .toString(),
        KEY_SPEC: JSON.stringify(keySpec),
      },
    });

    this.bucket.grantReadWrite(this.rotationLambda);

    this.secret = new secretsmanager.Secret(this, "JwksSecret", {
      secretName,
      description: "JWKS private keys for rotation",
      generateSecretString: {
        secretStringTemplate: JSON.stringify({ keySpec }),
        generateStringKey: "initialKey",
        excludeCharacters: '"\\/',
      },
    });

    this.secret.grantRead(this.rotationLambda);
    this.secret.grantWrite(this.rotationLambda);

    this.rotationLambda.addToRolePolicy(
      new iam.PolicyStatement({
        effect: iam.Effect.ALLOW,
        actions: [
          "secretsmanager:DescribeSecret",
          "secretsmanager:GetSecretValue",
          "secretsmanager:PutSecretValue",
          "secretsmanager:UpdateSecretVersionStage",
        ],
        resources: [this.secret.secretArn],
      }),
    );

    this.secret.addRotationSchedule("RotationSchedule", {
      rotationLambda: this.rotationLambda,
      automaticallyAfter: rotationInterval,
    });

    const cleanupRule = new events.Rule(this, "CleanupRule", {
      schedule: events.Schedule.rate(cleanupCheckInterval),
      description: "Trigger JWKS cleanup check",
    });

    cleanupRule.addTarget(
      new targets.LambdaFunction(this.rotationLambda, {
        event: events.RuleTargetInput.fromObject({
          action: "cleanup",
          secretArn: this.secret.secretArn,
        }),
      }),
    );

    this.rotationLambda.addPermission("AllowEventBridgeInvoke", {
      principal: new iam.ServicePrincipal("events.amazonaws.com"),
      sourceArn: cleanupRule.ruleArn,
    });
  }
}
